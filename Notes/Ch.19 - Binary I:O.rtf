{\rtf1\ansi\ansicpg1252\cocoartf2707
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Oblique;\f2\fswiss\fcharset0 Helvetica-Bold;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww28600\viewh14580\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 . Data stored in a text file are represented as a human-readable form. Whereas, data stored in a binary file are represented in binary form\
\
. Text files are designed to be read by text editors while binary files are designed to be read by programs.\
  Java source programs are stored in text files that can be read by text editors while the Java classes are stored as binary files in which they cannot be read by text editors but by the JVM\
\
. The benefit of binary files is that they are more efficient to process than text files\
\
. Java offers many classes for performing file input and output. These classes can be categorized as 
\f1\i text I/O classes
\f0\i0  and 
\f1\i binary I/O classes
\f0\i0 \
\
. An input object is referred to as an 
\f1\i input stream
\f0\i0  while an output object is referred to as an 
\f1\i output stream
\f0\i0 \
\
. Text I/O would require encoding and decoding of characters while Binary I/O does not\
\
. Binary files do not require encoding and decoding of characters which makes it more efficient. Which is also why Java classes are binary, making them more efficient, and can be run by the JVM on any system\
\
. All methods of the binary I/O classes are declared to throw an IOException\
\
. The class FileInputStream and FileOutputStream are for reading and writing from and to a binary file. Their methods are inherited from InputStream and OutputStream, and do not introduce any new method\
\
. 
\f2\b InputStream
\f0\b0  and 
\f2\b OutputStream
\f0\b0  are the base objects for all input and output stream objects\
\
. When a stream is no longer needed, it is better to use the 
\f2\b close()
\f0\b0  method. Not closing the stream may lead to data corruption in the output file, or other programming errors\
\
. A 
\f2\b FileInputStream
\f0\b0  can be used as an argument when constructing a 
\f2\b Scanner
\f0\b0 . And 
\f2\b FileOutputStream
\f0\b0  can be use to construct a 
\f2\b PrintWriter
\f0\b0 \
\
. In order to append data into a text file:\
					- Create a FileOutputStream that directs to the text file with 
\f2\b append
\f0\b0  set to true\
					- Use the instance of the output stream as an argument to construct a 
\f2\b PrintWriter
\f0\b0  object\
					- Any data written to the text file follows the existing content in the text file\
\
. DataInputStream reads byte from the stream and converts them into appropriate primitive data types or string values\
\
. DataOutputStream converts primitive data types or string values into bytes, and outputs these bytes into the stream\
\
. 
\f2\b DataInputStream
\f0\b0 /
\f2\b DataOutputStream
\f0\b0  extend 
\f2\b FilterInputStream
\f0\b0 /
\f2\b FilterOutputStream
\f0\b0 , in which they are the base classes for filtering bytes\
\
. When an Input Stream reaches the end of the file, and is still called on reading from the file, the program will throw an EOFException (End Of File Exception)\
\
. 
\f2\b BufferedInputStream
\f0\b0 /
\f2\b BufferedOutputStream
\f0\b0  can speed the reading/writing process\
\
. All the methods of 
\f2\b BufferedInputStream
\f0\b0 /
\f2\b BufferedOutputStream
\f0\b0  are inherited form 
\f2\b InputStream
\f0\b0 /
\f2\b OutputStream
\f0\b0 \
\
. 
\f2\b DataInputStream
\f0\b0 /
\f2\b DataOutputStream
\f0\b0  allow you to perform I/O for primitive data types. 
\f2\b ObjectInputStream
\f0\b0 /
\f2\b ObjectOutputStream
\f0\b0  allow you to perform I/O for objects in addition to primitive data types\
\
. Not all objects can be written to an output stream. Objects that can be written to output streams are called 
\f1\i serializable
\f0\i0  objects\
\
. If the program writes a non-serializable object to the output stream, n 
\f2\b NotSerializableException
\f0\b0  is thrown\
\
. In order for an object to become serializable, the object class must implement the 
\f2\b Serializable
\f0\b0  interface\
\
. When an object class implements the 
\f2\b Serializable
\f0\b0  interface, the object in addition to its properties are serialized\
\
. In a serialized object, any property that is 
\f2\b static
\f0\b0  or 
\f2\b transient
\f0\b0  is not serialized, and is ignored by the JVM in order for the object to be stored in the output stream without throwing an Exception\
\
. If a serialized object carries an instance of another object that is not serialized, the instance should either be placed 
\f2\b static
\f0\b0  or 
\f2\b transient
\f0\b0 , or the other object should implement the 
\f2\b Serializable
\f0\b0  interface to avoid a 
\f2\b NotSerializableException
\f0\b0 \
\
. An array is counted as a serializable object if all of its elements are serialized\
\
. To store an array into an output stream, Java allows the use of the 
\f2\b readObject()
\f0\b0  and 
\f2\b writeObject()
\f0\b0  methods\
\
. Java provides the 
\f2\b RandomAccessFile
\f0\b0  class that allows reading and writing primitive data\
\
. The 
\f2\b RandomAccessFile
\f0\b0  class implements 
\f2\b DataInput
\f0\b0  that defines methods for reading primitive data, and 
\f2\b DataOutput
\f0\b0  that defines methods for writing data\
\
. When a 
\f2\b RandomAccessFile
\f0\b0  instance is initialized with a given name of the file, if the file exists, the instance will direct to the file. Otherwise, a new file with the given file name is created\
\
. A 
\f2\b RandomAccessFile
\f0\b0  object consists of what is called a 
\f1\i file pointer
\f0\i0  in the file which is also a set of bytes\
\
. A 
\f1\i file pointer 
\f0\i0 is the marker in the file in which any operation executed by the object takes place at the location of the 
\f1\i file pointer. 
\f0\i0 So for every operation executed, the pointer is moved four bytes ahead\
 \
. For example: If a new 
\f2\b RandomAccessFile
\f0\b0  instance is initialized directing to a particular file, the file pointer by default is placed at position zero. When a one digit integer is read from the file, the file pointer is moved to after the integer at position four. And when a   character is written into the file, the character is written at position four, thus, where the file pointer is located after the integer that was read.\
It is also important to note that after a character was written to the file, the file pointer is then moved to position eight.}